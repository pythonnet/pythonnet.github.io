<html>
  <head>
    <title>Python for .NET</title>
    <style type="text/css"><!--

body { 
  font: 12pt/18pt georgia,verdana; 
  text-decoration: none;
  color: #555753; 
  background: #ffffff;
  margin: 0px; 
}

p { 
  font: 12pt/18pt georgia; 
}

h1 { 
  font: bold 16pt;
  color: #000044;
/*
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
*/
}

h2 { 
  font: bold 14pt;
  margin-bottom: 0px; 
  color: #000044;
}

h3 { 
  font: bold 12pt;
  margin-bottom: 0px;
  color: #000044; 
}

a:link { 
  font-weight: bold; 
  text-decoration: none; 
  color: #000066;
}

a:visited { 
  font-weight: bold; 
  text-decoration: none; 
  color: #000066;
}

a:hover, a:active { 
  text-decoration: underline; 
  color: #000066;
}

pre {
  font-family: monospace;
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
}

li { 
  font: 12pt/18pt georgia,verdana; 
  text-decoration: none;
  color: #555753; 
}

.spacer {
  font: bold 16pt;
}

.menu {
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
  font-size: x-small;
}

.menu ul {
  margin: 0px;
  padding: 0px;
}

//--></style>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  </head>
  <body>
    <table border="0" cellspacing="4" width="98%">
      <tbody>
        <tr>
          <td class="menu" align="left" valign="top" width="20%">
            <h1>Python for .NET</h1>
            <ul>
              <li><a href="#installation">Installation</a></li>
              <li><a href="#getting_started">Getting Started</a></li>
              <li><a href="#importing">Importing Modules</a></li>
              <li><a href="#classes">Using Classes</a></li>
              <li><a href="#generics">Using Generics</a></li>
              <li><a href="#fields">Fields and Properties</a></li>
              <li><a href="#indexers">Using Indexers</a></li>
              <li><a href="#methods">Using Methods</a></li>
              <li><a href="#genericmethods">Overloaded and Generic Methods</a></li>
              <li><a href="#delegates">Delegates and Events</a></li>
              <li><a href="#exceptions">Exception Handling</a></li>
              <li><a href="#arrays">Using Arrays</a></li>
              <li><a href="#collections">Using Collections</a></li>
              <li><a href="#com">COM Components</a></li>
              <li><a href="#types">Type Conversion</a></li>
              <li><a href="#embedding">Embedding Python</a></li>
              <li><a href="#license">License</a></li>
            </ul>
          </td>
          <td align="left" valign="top">
            <p> Python for .NET (pythonnet) is a package that gives Python programmers
              nearly seamless integration with the .NET 4.0+ Common Language Runtime
              (CLR) on Windows and Mono runtime on Linux and OSX. 
              Python for .NET provides a powerful application scripting tool for .NET
              developers. Using this package you can script .NET applications or
              build entire applications in Python, using .NET services and
              components written in any language that targets the CLR (C#, VB.NET, F#, C++/CLI).
            </p>
            <p> Note that this package does <em>not</em> implement Python as a
              first-class CLR language - it does not produce managed code (IL)
              from Python code. Rather, it is an integration of the CPython
              engine with the .NET or Mono runtime. This approach allows you to use
              CLR services and continue to use existing Python code and C-API
              extensions while maintaining native execution speeds for Python
              code. If you are interested in a pure managed-code implementation
              of the Python language, you should check out the <a href="http://www.ironpython.com">IronPython</a>
              project, which is in active development.
            </p>
            <p> Python for .NET is currently compatible and tested with Python releases 2.7, 3.3, 3.4, 3.5, and 3.6.
                Current releases are available at the <a href="http://pythonnet.github.io/">
                Python for .NET website </a>. To subscribe to the <a href="http://mail.python.org/mailman/listinfo/pythondotnet">
                Python for .NET mailing list </a> or read the <a href="http://mail.python.org/pipermail/pythondotnet/">
                online archives </a> of the list, see the <a href="http://mail.python.org/mailman/listinfo/pythondotnet">
                mailing list information </a> page. </p>
            <a name="#installation"></a>
            <h2>Installation</h2>
            <p> Python for .NET is available as a source release on 
              <a href="https://github.com/pythonnet/pythonnet/releases"> GitHub </a>
              and as a binary wheel distribution for all supported versions of Python 
              and the common language runtime from the <a href="https://pypi.python.org/pypi/pythonnet">
              Python Package Index </a>.
            </p>
            
            <p> The source release is a self-contained "private" assembly. Just
              unzip the package wherever you want it, cd to that directory, 
              build the solution <strong>python setup.py build_ext --inplace</strong>.
              Once you start up Python or IPython interpreter in this directory or
              append this directory to <strong>sys.path</strong>, 
              then after <strong>import clr</strong> statement .NET assemblies can be used. 
              You can also run <strong>nPython.exe</strong> (<strong>mono nPython.exe</strong> on *nix) 
              to check how python can be embedded in console .NET application. 
              Note that the source release does not include a copy of the CPython runtime, 
              so you will need to have installed Python on your machine before using 
              the source release.
            </p>
            <p> <strong>Running on Linux/Mono:</strong> Unit testing
              shows that PythonNet will run under <a href="http://www.go-mono.com">Mono</a>,
              though the Mono runtime is less supported so there still may be
              problems.
            </p>
            <a name="getting_started"></a>
            <h2>Getting Started</h2>
            <p> A key goal for this project has been that Python for .NET should
              "work just the way you'd expect in Python", except for cases that
              are .NET specific (in which case the goal is to work "just the way
              you'd expect in C#"). In addition, with the IronPython project
              having established a community, it is my goal that code written for IronPython
              run without modification under Python for .NET.
            </p>
            <p> If you already know Python, you can probably finish this readme
              and then refer to .NET docs to figure out anything you need to do.
              Conversely if you are familiar with C# or another .NET language,
              you probably just need to pick up one of the many good Python
              books or read the Python tutorial online to get started.
            </p>
            <p> A good way to start is to interactively explore 
              .NET usage in python interpreter by
              following along with the examples in this document. If you get stuck,
              there are also a number of demos and unit tests located in the
              source directory of the distribution that can be helpful as
              examples.
            </p>
            <a name="importing"></a>
            <h2>Importing Modules</h2>
            <p> Python for .NET allows CLR namespaces to be treated essentially
              as Python packages. </p>
            <p>
            </p>
            <pre>    from System import String
    from System.Collections import *
</pre>
            <p> Types from any loaded assembly may be imported and used in this
              manner. To load an assembly, use the "AddReference" function in
              the "clr" module:
            </p>
            <pre>
    import clr
    clr.AddReference("System.Windows.Forms")
    from System.Windows.Forms import Form

</pre>
            <p>
              <em> Note that earlier releases of Python for .NET relied on
                "implicit loading" to support automatic loading of assemblies
                whose names corresponded to an imported namespace. Implicit
                loading still works for backward compatibility, but will be
                removed in a future release so it is recommended to use the
                clr.AddReference method.
              </em>
            </p>
            <p> Python for .NET uses the PYTHONPATH (sys.path) to look for
              assemblies to load, in addition to the usual application base and
              the GAC. To ensure that you can implicitly import an assembly, put
              the directory containing the assembly in <code>sys.path</code>.
            </p>
            <a name="classes"></a>
            <h2>Using Classes</h2>
            <p> Python for .NET allows you to use any non-private classes,
              structs, interfaces, enums or delegates from Python. To create an
              instance of a managed class, you use the standard instantiation
              syntax, passing a set of arguments that match one of its public
              constructors:
            </p>
            <pre>    from System.Drawing import Point

    p = Point(5, 5)
</pre>
            <p> In most cases, Python for .NET can determine the correct
              constructor to call automatically based on the arguments. In some
              cases, it may be necessary to call a particular overloaded
              constructor, which is supported by a special "__overloads__"
              attribute, which will soon be deprecated in favor of iPy
              compatible "Overloads", on a class:
            </p>
            <pre>    from System import String, Char, Int32

    s = String.Overloads[Char, Int32]('A', 10)
    s = String.__overloads__[Char, Int32]('A', 10)
</pre>
            <a name="generics"></a>
            <h2>Using Generics</h2>
            <p> Pythonnet also supports generic types. A generic type must be bound to
              create a concrete type before it can be instantiated. Generic
              types support the subscript syntax to create bound types:
            </p>
            <pre>    from System.Collections.Generic import Dictionary
    from System import *

    dict1 = Dictionary[String, String]()
    dict2 = Dictionary[String, Int32]()
    dict3 = Dictionary[String, Type]()
</pre>
            <p> When you pass a list of types using the subscript syntax, you
              can also pass a subset of Python types that directly correspond to
              .NET types:
            </p>
            <pre>    dict1 = Dictionary[str, str]()
    dict2 = Dictionary[str, int]()
    dict3 = Dictionary[str, Decimal]()
</pre>
            <p> This shorthand also works when explicitly selecting generic
              methods or specific versions of overloaded methods and
              constructors (explained later).
            </p>
            <p> You can also subclass managed classes in Python, though members
              of the Python subclass are not visible to .NET code. See the <code>helloform.py</code>
              file in the <code>/demo</code> directory of the distribution for
              a simple Windows Forms example that demonstrates subclassing a
              managed class.
            </p>
            <a name="fields"></a>
            <h2>Fields And Properties</h2>
            <p> You can get and set fields and properties of CLR objects just as
              if they were regular attributes:
            </p>
            <pre>    from System import Environment

    name = Environment.MachineName
    Environment.ExitCode = 1
</pre>
            <a name="indexers"></a>
            <h2>Using Indexers</h2>
            <p> If a managed object implements one or more indexers, you can
              call the indexer using standard Python indexing syntax:
            </p>
            <pre>    from System.Collections import Hashtable

    table = Hashtable()
    table["key 1"] = "value 1"
</pre>
            <p> Overloaded indexers are supported, using the same notation one
              would use in C#:
            </p>
            <pre>    items[0, 2]

    items[0, 2, 3]
</pre>
            <a name="methods"></a>
            <h2>Using Methods</h2>
            <p> Methods of CLR objects behave generally like normal Python
              methods. Static methods may be called either through the class or
              through an instance of the class. All public and protected methods
              of CLR objects are accessible to Python:
            </p>
            <pre>    from System import Environment

    drives = Environment.GetLogicalDrives()
</pre>
            <p> It is also possible to call managed methods <code>unbound</code>
              (passing the instance as the first argument) just as with Python
              methods. This is most often used to explicitly call methods of a
              base class.
            </p>
            <p> <em>Note that there is one caveat related to calling unbound
                methods: it is possible for a managed class to declare a static
                method and an instance method with the same name. Since it is
                not possible for the runtime to know the intent when such a
                method is called unbound, the static method will always be
                called.</em>
            </p>
            <p> The docstring of CLR a method (__doc__) can be used to view the
              signature of the method, including overloads if the CLR method is
              overloaded. You can also use the Python <code>help</code> method
              to inspect a managed class:
            </p>
            <pre>    from System import Environment

    print(Environment.GetFolderPath.__doc__)

    help(Environment)
</pre>
            <a name="genericmethods"></a>
            <h2>Overloaded and Generic Methods</h2>
            <p> While Python for .NET will generally be able to figure out the
              right version of an overloaded method to call automatically, there
              are cases where it is desirable to select a particular method
              overload explicitly.
            </p>
            <p> Methods of CLR objects have an "__overloads__", which will soon
              be deprecated in favor of iPy compatible Overloads, attribute that
              can be used for this purpose :
            </p>
            <pre>    from System import Console

    Console.WriteLine.Overloads[bool](true)
    Console.WriteLine.Overloads[str]("true")
    Console.WriteLine.__overloads__[int](42)
</pre>
            <p> Similarly, generic methods may be bound at runtime using the
              subscript syntax directly on the method:
            </p>
            <pre>    someobject.SomeGenericMethod[int](10)
    someobject.SomeGenericMethod[str]("10")
</pre>
            <a name="delegates"></a>
            <h2>Delegates And Events</h2>
            <p> Delegates defined in managed code can be implemented in Python.
              A delegate type can be instantiated and passed a callable Python
              object to get a delegate instance. The resulting delegate instance
              is a true managed delegate that will invoke the given Python
              callable when it is called:
            </p>
            <pre>    def my_handler(source, args):
        print('my_handler called!')

    # instantiate a delegate
    d = AssemblyLoadEventHandler(my_handler)

    # use it as an event handler
    AppDomain.CurrentDomain.AssemblyLoad += d
</pre>
            <p> Multicast delegates can be implemented by adding more callable
              objects to a delegate instance:
            </p>
            <pre>    d += self.method1
    d += self.method2
    d()
</pre>
            <p> Events are treated as first-class objects in Python, and behave
              in many ways like methods. Python callbacks can be registered with
              event attributes, and an event can be called to fire the event.
            </p>
            <p> Note that events support a convenience spelling similar to that
              used in C#. You do not need to pass an explicitly instantiated
              delegate instance to an event (though you can if you want). Events
              support the <code>+=</code> and <code>-=</code> operators in a
              way very similar to the C# idiom:
            </p>
            <pre>    def handler(source, args):
        print('my_handler called!')

    # register event handler
    object.SomeEvent += handler

    # unregister event handler
    object.SomeEvent -= handler

    # fire the event
    result = object.SomeEvent(...)
</pre>
            <a name="exceptions"></a>
            <h2>Exception Handling</h2>
            <p> You can raise and catch managed exceptions just the same as you
              would pure-Python exceptions:
            </p>
            <pre>    from System import NullReferenceException

    try:
        raise NullReferenceException("aiieee!")
    except NullReferenceException as e:
        print(e.Message)
        print(e.Source)
</pre>
            <p></p>
            <a name="arrays"></a>
            <h2>Using Arrays</h2>
            <p> The type <code>System.Array</code> supports the subscript
              syntax in order to make it easy to create managed arrays from
              Python:
            </p>
            <pre>    from System import Array

    myarray = Array[int](10)
</pre>
            <p> Managed arrays support the standard Python sequence protocols:
            </p>
            <pre>    items = SomeObject.GetArray()

    # Get first item
    v = items[0]
    items[0] = v

    # Get last item
    v = items[-1]
    items[-1] = v

    # Get length
    l = len(items)

    # Containment test
    test = v in items
</pre>
            <p> Multidimensional arrays support indexing using the same notation
              one would use in C#:
            </p>
            <pre>    items[0, 2]

    items[0, 2, 3]
</pre>
            <a name="collections"></a>
            <h2>Using Collections</h2>
            <p> Managed arrays and managed objects that implement the
              IEnumerable interface can be iterated over using the standard
              iteration Python idioms:
            </p>
            <pre>    domain = System.AppDomain.CurrentDomain

    for item in domain.GetAssemblies():
        name = item.GetName()
</pre>
            <a name="com"></a>
            <h2>Using COM Components</h2>
            <p> Using Microsoft-provided tools such as <strong>aximp.exe</strong>
              and <strong>tlbimp.exe</strong>, it is possible to generate
              managed wrappers for COM libraries. After generating such a
              wrapper, you can use the libraries from Python just like any other
              managed code.
            </p>
            <p> Note: currently you need to put the generated wrappers in the
              GAC, in the PythonNet assembly directory or on the PYTHONPATH in
              order to load them.
            </p>
            <a name="types"></a>
            <h2>Type Conversion</h2>
            <p> Type conversion under Python for .NET is fairly straightforward
              - most elemental Python types (string, int, long, etc.) convert
              automatically to compatible managed equivalents (String, Int32,
              etc.) and vice-versa. Note that all strings returned from the CLR
              are returned as unicode.
            </p>
            <p> Types that do not have a logical equivalent in Python are
              exposed as instances of managed classes or structs (System.Decimal
              is an example).
            </p>
            <p> The .NET architecture makes a distinction between <code>value
                types</code> and <code>reference types</code>. Reference types
              are allocated on the heap, and value types are allocated either on
              the stack or in-line within an object.
            </p>
            <p> A process called <code>boxing</code> is used in .NET to allow
              code to treat a value type as if it were a reference type. Boxing
              causes a separate copy of the value type object to be created on
              the heap, which then has reference type semantics.
            </p>
            <p> Understanding boxing and the distinction between value types and
              reference types can be important when using Python for .NET
              because the Python language has no value type semantics or syntax
              - in Python "everything is a reference".
            </p>
            <p> Here is a simple example that demonstrates an issue. If you are
              an experienced C# programmer, you might write the following code:
            </p>
            <pre>    items = System.Array.CreateInstance(Point, 3)
    for i in range(3):
        items[i] = Point(0, 0)

    items[0].X = 1 # won't work!!
</pre>
            <p> While the spelling of <code>items[0].X = 1</code> is the same
              in C# and Python, there is an important and subtle semantic
              difference. In C# (and other compiled-to-IL languages), the
              compiler knows that Point is a value type and can do the Right
              Thing here, changing the value in place.
            </p>
            <p> In Python however, "everything's a reference", and there is
              really no spelling or semantic to allow it to do the right thing
              dynamically. The specific reason that <code>items[0]</code>
              itself doesn't change is that when you say <code>items[0]</code>,
              that getitem operation creates a Python object that holds a
              reference to the object at <code>items[0]</code> via a GCHandle.
              That causes a ValueType (like Point) to be boxed, so the following
              setattr (<code>.X = 1</code>) <em>changes the state of the boxed
                value, not the original unboxed value</em>.
            </p>
            <p> The rule in Python is essentially: "the result of any attribute
              or item access is a boxed value", and that can be important in how
              you approach your code.
            </p>
            <p> Because there are no value type semantics or syntax in Python,
              you may need to modify your approach. To revisit the previous
              example, we can ensure that the changes we want to make to an
              array item aren't "lost" by resetting an array member after making
              changes to it:
            </p>
            <pre>    items = System.Array.CreateInstance(Point, 3)
    for i in range(3):
        items[i] = Point(0, 0)

    # This _will_ work. We get 'item' as a boxed copy of the Point
    # object actually stored in the array. After making our changes
    # we re-set the array item to update the bits in the array.

    item = items[0]
    item.X = 1
    items[0] = item
</pre>
            <p> This is not unlike some of the cases you can find in C# where
              you have to know about boxing behavior to avoid similar kinds of <code>lost
                update</code> problems (generally because an implicit boxing
              happened that was not taken into account in the code).
            </p>
            <p> This is the same thing, just the manifestation is a little
              different in Python. See the .NET documentation for more details
              on boxing and the differences between value types and reference
              types.
            </p>
            <a name="embedding"></a>
            <h2>Embedding Python</h2>
            <p> <strong>Note:</strong> because Python code running under Python
              for .NET is inherently unverifiable, it runs totally under the
              radar of the security infrastructure of the CLR so you should
              restrict use of the Python assembly to trusted code.
            </p>
            <p> The Python runtime assembly defines a number of public classes
              that provide a subset of the functionality provided by the Python
              C-API.
            </p>
            <p> These classes include PyObject, PyList, PyDict, PyTuple, etc. 
              You can review the nPython.exe source code in in "Console.csproj" project 
              for example of embedding CPython in console .NET app.
              Please refer to this README GitHub page for new simplified embedding API:
            </p>  
            <p>
              <a href="https://github.com/pythonnet/pythonnet/blob/master/README.md"> README.md </a>
            </p>  
            <p> At a very high level, to embed Python in your application you
              will need to:
            </p>
            <ul>
              <li>Reference Python.Runtime.dll in your build environment</li>
              <li>Call PythonEngine.Intialize() to initialize Python</li>
              <li>Call PythonEngine.ImportModule(name) to import a module</li>
            </ul>
            <p> The module you import can either start working with your managed
              app environment at the time its imported, or you can explicitly
              lookup and call objects in a module you import.
            </p>
            <p> For general-purpose information on embedding Python in
              applications, use www.python.org or Google to find (C) examples.
              Because Python for .NET is so closely integrated with the managed
              environment, you will generally be better off importing a module
              and deferring to Python code as early as possible rather than
              writing a lot of managed embedding code.
            </p>
            <p> <strong>Important Note for embedders:</strong> Python is not
              free-threaded and uses a global interpreter lock to allow
              multi-threaded applications to interact safely with the Python
              interpreter. Much more information about this is available in the
              Python C-API documentation on the www.python.org Website.
            </p>
            <p> When embedding Python in a managed application, you have to
              manage the GIL in just the same way you would when embedding
              Python in a C or C++ application.
            </p>
            <p> Before interacting with any of the objects or APIs provided by
              the Python.Runtime namespace, calling code must have acquired the
              Python global interpreter lock by calling the <code>PythonEngine.AcquireLock</code>
              method. The only exception to this rule is the <code>PythonEngine.Initialize</code>
              method, which may be called at startup without having acquired the
              GIL.
            </p>
            <p> When finished using Python APIs, managed code must call a
              corresponding <code>PythonEngine.ReleaseLock</code> to release
              the GIL and allow other threads to use Python.
            </p>
            <p> The AcquireLock and ReleaseLock methods are thin wrappers over
              the unmanaged <code>PyGILState_Ensure</code> and <code>PyGILState_Release</code>
              functions from the Python API, and the documentation for those
              APIs applies to the managed versions.
            </p>
            <a name="license">
              <h2>License</h2>
            </a>
            <p><a name="license"> Python for .NET is released under the open
                source MIT License. A copy of the license is included
                in the distribution, or you can find a copy of the </a><a href="http://pythonnet.github.io/LICENSE">
                license online </a>. Some distributions of this package include a
              copy of the C Python dlls and standard library, which are covered
              by the <a href="http://www.python.org/license.html"> Python
                license </a>.
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
